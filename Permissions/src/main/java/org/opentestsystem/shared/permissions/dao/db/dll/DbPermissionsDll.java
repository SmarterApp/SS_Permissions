/*******************************************************************************
 * Educational Online Test Delivery System Copyright (c) 2013 American
 * Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0 See accompanying
 * file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.permissions.dao.db.dll;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.apache.http.client.HttpResponseException;
import org.opentestsystem.shared.permissions.data.AllowableEntityType;
import org.opentestsystem.shared.permissions.data.Component;
import org.opentestsystem.shared.permissions.data.Permission;
import org.opentestsystem.shared.permissions.data.Role;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import AIR.Common.DB.AbstractDLL;
import AIR.Common.DB.SQLConnection;
import AIR.Common.DB.SqlParametersMaps;
import AIR.Common.DB.results.DbResultRecord;
import AIR.Common.DB.results.SingleDataResultSet;
import TDS.Shared.Exceptions.ReturnStatusException;

public class DbPermissionsDll extends AbstractDLL
{
  private static final Logger _logger = LoggerFactory.getLogger (DbPermissionsDll.class);

  /**
   * Gets all components including permissions
   */
  public List<Component> getAllComponents (SQLConnection connection) throws ReturnStatusException {
    List<Component> returnList = new ArrayList<Component> ();
    final String SQL = "select distinct name from component order by name;";
    
      SingleDataResultSet results = executeStatement (connection, SQL,
          new SqlParametersMaps (), false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        DbResultRecord record = records.next ();
        // build the component from the db record.
        Component c = new Component ();
        c.setComponent (record.<String> get ("name"));
        // get the Permissions from Component
        List<Permission> permissions = getPermissionsByComponent (connection, c.getComponent ());
        c.setPermissions (permissions);
        // add component it to our outgoing list.
        returnList.add (c);
      }
      return returnList;
  }

  /**
   * Get all roles including allowable entities and components/permissions that they 
   * have association with.
   * 
   * @return
   * @throws ReturnStatusException
   */
  public Collection<Role> getAllRoles (SQLConnection connection) throws ReturnStatusException {
	List<Role> returnList = new ArrayList<Role> ();
    final String SQL1 = "select role.name as name, permission.name as permissionname, component.name as componentname from role left outer join permission_role on permission_role._fk_rid=role._id left outer join permission on permission_role._fk_pid=permission._id left outer join component on permission_role._fk_cid=component._id order by role.name, componentname;";

    SingleDataResultSet results1 = executeStatement (connection, SQL1, new SqlParametersMaps (), false).getResultSets ().next ();
    Iterator<DbResultRecord> permissionRecords = results1.getRecords ();
      
    final String SQL2 = "SELECT role.name as rolename, entitytype.name, entitytype.unique_key from role, entitytype, role_entity where role_entity._fk_rid = role._id and entitytype.unique_key = role_entity._fk_etuk order by rolename;";
	  
	SingleDataResultSet results2 = executeStatement (connection, SQL2, new SqlParametersMaps (), false).getResultSets ().next ();
	Iterator<DbResultRecord> entityRecords = results2.getRecords ();
    loadRoles (connection, permissionRecords, entityRecords, returnList);    
    
    return returnList;
  }

  private void loadRoles (SQLConnection connection, Iterator<DbResultRecord> permissionRecords, Iterator<DbResultRecord> entityRecords, List<Role> returnList) throws ReturnStatusException {
    String prevrolename = null, prevcomponentname = null;
    Role role = null;
    Component comp = null;
    while (permissionRecords.hasNext ()) {
      DbResultRecord record = permissionRecords.next ();

      // build the role from the db record.
      String rolename = record.<String> get ("name");
      if (!rolename.equals (prevrolename)) {
        role = new Role ();
        role.setRole (rolename);
        prevcomponentname = null;
        // add the Role to our outgoing list of Roles
        returnList.add (role);
      }

      String componentname = record.<String> get ("componentname");
      if (componentname != null) {
        if (!componentname.equals (prevcomponentname)) {
          comp = new Component ();
          comp.setComponent (componentname);
          role.addComponent (comp);
        }
        Permission p = new Permission ();
        p.setName (record.<String> get ("permissionname"));
        comp.addPermission (p);
      }

      if (entityRecords == null) {
    	  // For each role, get list of Allowable Entity Types
    	  List<AllowableEntityType> allowableEntities = (List<AllowableEntityType>) getAllAllowableEntitiesByRoleName (connection, rolename);
    	  role.setAllowableEntities (allowableEntities);
      }

      prevrolename = rolename;
      prevcomponentname = componentname;
    }
    
    if (entityRecords != null) {
    	loadEntities(entityRecords, returnList);
    }
  }
  
  private void loadEntities(Iterator<DbResultRecord> entityRecords, List<Role> returnList) throws ReturnStatusException {  
	  String prevrolename = null;
	  int roldindx = 0;
	  Role role = null;
	  while (entityRecords.hasNext ()) {
	      DbResultRecord record = entityRecords.next ();
	      
	      String rolename = record.<String> get ("rolename");
	      if (!rolename.equals (prevrolename)) {
	    	  boolean foundrole = false;
	    	  while (roldindx < returnList.size()) {
	    		  role = returnList.get(roldindx);
	    		  if (role.getRole().equals(rolename)) {
	    			  foundrole = true;
	    			  break;
	    		  }
	    		  roldindx++;
	    	  }
	    	  if (!foundrole) break;
	      }

	      AllowableEntityType type = new AllowableEntityType ();
	      type.setDescription (record.<String> get ("name"));
	      type.setEntity (record.<String> get ("unique_key"));

	      role.getAllowableEntities().add(type);

	      prevrolename = rolename;
	  }
  }

  /**
   * Gets a role with a given name including allowable entities, components and permissions
   * that it is associated with.
   * 
   * @param name
   * @return the specified Role
   * @throws ReturnStatusException
   */
  public Role getRoleByRoleName (SQLConnection connection, String name) throws ReturnStatusException {
    final String SQL = "select role.name as name, permission.name as permissionname, component.name as componentname from role left outer join permission_role on permission_role._fk_rid=role._id left outer join permission on permission_role._fk_pid=permission._id left outer join component on permission_role._fk_cid=component._id where role.name=${roleName} order by role.name, componentname;";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", name);
    List<Role> returnList = new ArrayList<Role> ();
    
      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      loadRoles (connection, records, null, returnList);
      if (returnList.size () > 0)
        return returnList.get (0);
      return null;
  }

  /**
   * Gets a component with a given name and its permissions.
   * 
   * @param name
   * @return
   * @throws ReturnStatusException
   */
  public Component getComponentByComponentName (SQLConnection connection, String name) throws ReturnStatusException {
    final String SQL = "select name from component where component.name = ${compName} ;";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compName", name);

      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      Component c = null;
      while (records.hasNext ()) {
        c = new Component ();
        DbResultRecord record = records.next ();
        // Get and set name of component
        c.setComponent (record.<String> get ("name"));
        // Get and set Permissions for component
        c.setPermissions (getPermissionsByComponent (connection, name));
      }
      return c;
  }

  /**
   * Gets all roles (including allowable entities) that have mappings to a
   * specific component
   * 
   * @param componentName
   * @return
   * @throws ReturnStatusException
   */
  public List<Role> getRoleByComponent (SQLConnection connection, String componentName) throws ReturnStatusException {
    List<Role> roles = new ArrayList<Role> ();
    final String SQL = "select role.name as name, permission.name as permissionname, component.name as componentname from role left outer join permission_role on permission_role._fk_rid=role._id left outer join permission on permission_role._fk_pid=permission._id left outer join component on permission_role._fk_cid=component._id where component.name=${compName} order by role.name, componentname;";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compName", componentName);

      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      loadRoles (connection, records, null, roles);
      return roles;
  }

  public void addEntity (SQLConnection connection, String roleId, String entity) throws ReturnStatusException {
    AllowableEntityType type = getAllowableEntityTypeByName (connection, entity);
    final String SQL = "insert into role_entity values((select _id from role where name = ${roleName}), ${entityUniqKey} );";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleId).put ("entityUniqKey", type.getEntity ());

    executeStatement (connection, SQL, parameters, false);
    
  }

  public void deleteEntity (SQLConnection connection, String roleId, String entity) throws ReturnStatusException {
    AllowableEntityType type = getAllowableEntityTypeByName (connection, entity);
    final String SQL = "DELETE from role_entity where _fk_rid = (select _id from role where name = ${roleName}) and _fk_etuk = ${unique_key};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleId).put ("unique_key", type.getEntity ());

    executeStatement (connection, SQL, parameters, false);
  }

  public void editRole (SQLConnection connection, String roleId, String newRole) throws ReturnStatusException, HttpResponseException {
    // Check if role exists or not.
    Role r = this.getRoleByRoleName (connection, newRole);
    if (r != null)
      throw new HttpResponseException (409, "Already exists.");

    final String SQL = "UPDATE role set role.name = ${newName} where role.name = ${roleName};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleId).put ("newName", newRole);

    executeStatement (connection, SQL, parameters, false);
  }

  public void addRole (SQLConnection connection, String roleId) throws ReturnStatusException, HttpResponseException {
    // Check if role exists or not.
    Role r = this.getRoleByRoleName (connection, roleId);
    if (r != null)
      throw new HttpResponseException (409, "Role already exists.");

    final String SQL = "insert into role (name) values(${roleName});";
    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleId);
    
    executeStatement (connection, SQL, parameters, false);
  }

  public void deleteRole (SQLConnection connection, String roleId) throws ReturnStatusException {
    final String SQL = "DELETE from role where name = ${roleName};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleId);

    executeStatement (connection, SQL, parameters, false);
  }

  public void addComponent (SQLConnection connection, String componentId) throws ReturnStatusException, HttpResponseException {
    // check if the component already exists or not
    Component c = getComponentByComponentName (connection, componentId);
    if (c != null)
      throw new HttpResponseException (409, "Component already exists.");

    final String SQL = "insert into component (name) values(${compID});";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compID", componentId);

    executeStatement (connection, SQL, parameters, false);
    
  }

  public void addPermission (SQLConnection connection, String componentId, String permissionId) throws ReturnStatusException, HttpResponseException {    
    // check component already has permission or not
    if (this.getComponentByComponentName (connection, componentId).containsPermission (permissionId)) {
      throw new HttpResponseException (409, componentId + " already has Permission [" + permissionId + "].");
    }

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("permName", permissionId).put ("compName", componentId);

    // Check if new permission. If new permission, we need to add new permission
    // to DB, then add to role-component-permission mapping
    // If not new, we add component and permission combination to DB

    // Check if new permission
    Permission p = new Permission ();
    p.setName (permissionId);
    if (!(getAllPermissions (connection).contains (p))) {
      // Insert new permission into database
      final String SQL = "insert into permission (name) values(${permName});";

      executeStatement (connection, SQL, parameters, false);
    }

    // Now Add Component-Permission combination
    // Check if there are associations between this pair already
    final String SQL2 = "SELECT DISTINCT permission._id from permission_role, component, permission where component.name = ${compName} and permission_role._fk_cid=component._id and permission_role._fk_pid = permission._id and permission.name = ${permName};";

      SingleDataResultSet results = executeStatement (connection, SQL2,
          parameters, false).getResultSets ().next ();
      Integer id = null;
      Iterator<DbResultRecord> records = results.getRecords ();
      if (records.hasNext ()) {
        DbResultRecord record = records.next ();
        id = (record.<Integer> get ("_id"));
      }
      // TODO: Ayo: separate methods for following SQL scripts ?
      String SQL3 = "";
      if (id == null) {
        // No instance of this component with an empty permission reference
        // field.
        SQL3 = "insert into permission_role ( _fk_rid, _fk_cid, _fk_pid) values (null, (select _id from component where name = ${compName}), (select _id from permission where name = ${permName}));";
        executeStatement (connection, SQL3, parameters, false);
      } 
  }

  public void editComponent (SQLConnection connection, String componentId, String newComponent) throws ReturnStatusException, HttpResponseException {
    // check if the component already exists or not
    Component c = getComponentByComponentName (connection, newComponent);
    if (c != null)
      throw new HttpResponseException (409, "Component already exists.");

    final String SQL = "UPDATE component set component.name = ${newName} where component.name = ${compName};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compName", componentId).put ("newName", newComponent);

    executeStatement (connection, SQL, parameters, false);
  }

  public void deleteComponent (SQLConnection connection, String componentId) throws ReturnStatusException {
    final String SQL = "DELETE from component where name = ${compName};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compName", componentId);

    executeStatement (connection, SQL, parameters, false);
  }

  public void deletePermission (SQLConnection connection, String componentId, String permissionId) throws ReturnStatusException {
    final String SQL = "delete from permission_role where _fk_cid = (select component._id from component where component.name = ${compName}) and _fk_pid = (select permission._id from permission where permission.name = ${permName})";
    
    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("permName", permissionId).put ("compName", componentId);

    executeStatement (connection, SQL, parameters, false);
    // TODO Ayo: Check if any other component is referencing Permission. If not,
    // delete Permission from DB. Check with Shiva 1st.
  }

  public void addMapping (SQLConnection connection, String componentId, String permissionId, String roleId) throws ReturnStatusException {
	//TODO check if null role is associated with this component/permission
    final String SQL = "insert into permission_role (_fk_rid, _fk_cid, _fk_pid) values((select _id from role where name = ${roleName}), (select _id from component where name = ${compName}), (select _id from permission where name = ${permName}))";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleId).put ("compName", componentId).put ("permName", permissionId);

    executeStatement (connection, SQL, parameters, false);
  }

  public void editPermission (SQLConnection connection, String componentId, String permissionId, String newPermission) throws ReturnStatusException {

    // Check if newPermission is in DB
    Permission p = getPermission (connection, newPermission);

    if (p == null) {
      // Permission does not exist. Add to database
      final String SQL_addPermission = "insert into permission (name) values(${permID});";

      SqlParametersMaps parameters = new SqlParametersMaps ();
      parameters.put ("permID", newPermission);

      executeStatement (connection, SQL_addPermission, parameters, false);
      
    } else {
      for (Permission permission : getComponentByComponentName (connection, componentId).getPermissions ())
      {
        if (StringUtils.equals (newPermission.toLowerCase (), permission.getName ().toLowerCase ()))
          throw new ReturnStatusException ("Duplicate permission.");
      }
    }

    final String SQL = "UPDATE permission_role, component set permission_role._fk_pid = (select _id from permission where name = ${newName}) where component.name = ${compName} and component._id = permission_role._fk_cid and permission_role._fk_pid = (select _id from permission where name = ${permName});";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("newName", newPermission).put ("permName", permissionId).put ("compName", componentId);

    executeStatement (connection, SQL, parameters, false);
  }

  public void deleteMapping (SQLConnection connection, String componentId, String permissionId, String roleId) throws ReturnStatusException {

    final String SQL = "DELETE from permission_role where _fk_pid = (select _id from permission where name = ${permName}) and _fk_cid = (select _id from component where name = ${compName}) and _fk_rid = (select _id from role where name = ${roleName});";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("permName", permissionId).put ("compName", componentId).put ("roleName", roleId);

    executeStatement (connection, SQL, parameters, false);
  }

  /**
   * What are all the roles that have mappings to this component and this
   * component's permission?
   * 
   * @throws ReturnStatusException
   */
  public List<Role> getRoleByComponentandPermission (SQLConnection connection, String componentName, String permission) throws ReturnStatusException {
    ArrayList<Role> roles = new ArrayList<Role> ();
    final String SQL = "SELECT role.name from role, component, permission, permission_role where permission_role._fk_pid = permission._id and permission_role._fk_rid = role._id and permission_role._fk_cid = component._id and component.name = ${compName} and permission.name = ${permName} ;";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compName", componentName).put ("permName", permission);

      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        Role r = new Role ();
        DbResultRecord record = records.next ();
        r.setRole (record.<String> get ("name"));
        // For the role, build a list of Allowable Entity Types
        r.setAllowableEntities ((List<AllowableEntityType>) getAllAllowableEntitiesByRoleName (connection, r.getRole ()));
        roles.add (r);
      }

      return roles;
  }

  public List<Component> getComponentByRole (SQLConnection connection, String roleName) throws ReturnStatusException {
    ArrayList<Component> components = new ArrayList<Component> ();
    final String SQL = "SELECT distinct component.name from role, component, permission, permission_role where permission_role._fk_pid = permission._id and permission_role._fk_rid = role._id and permission_role._fk_cid = component._id and role.name = ${roleName};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleName);

      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        Component c = new Component ();
        DbResultRecord record = records.next ();
        c.setComponent (record.<String> get ("name"));
        c.setPermissions (getPermissionsByComponent (connection, c.getComponent ()));
        components.add (c);
      }
      return components;
  }

  public List<Permission> getPermissionByRoleAndComponent (SQLConnection connection, String roleName, String componentName) throws ReturnStatusException {
    ArrayList<Permission> permissions = new ArrayList<Permission> ();
    final String SQL = "SELECT distinct permission.name from role, component, permission, permission_role where permission_role._fk_pid = permission._id and permission_role._fk_rid = role._id and permission_role._fk_cid = component._id and role.name = ${roleName} and component.name = ${compName};";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("roleName", roleName).put ("compName", componentName);

      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        Permission p = new Permission ();
        DbResultRecord record = records.next ();
        p.setName (record.<String> get ("name"));
        permissions.add (p);
      }
      return permissions;
  }

  public Collection<AllowableEntityType> getAllAllowableEntities (SQLConnection connection) throws ReturnStatusException {
    ArrayList<AllowableEntityType> entityTypes = new ArrayList<AllowableEntityType> ();
    final String SQL = "SELECT name, unique_key FROM entitytype;";

      SingleDataResultSet results = executeStatement (connection, SQL,
          new SqlParametersMaps (), false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        AllowableEntityType type = new AllowableEntityType ();
        DbResultRecord record = records.next ();
        type.setDescription (record.<String> get ("name"));
        type.setEntity (record.<String> get ("unique_key"));
        entityTypes.add (type);
      }
      return entityTypes;
  }

  private Collection<AllowableEntityType> getAllAllowableEntitiesByRoleName (SQLConnection connection, String roleName) throws ReturnStatusException {
    ArrayList<AllowableEntityType> entityTypes = new ArrayList<AllowableEntityType> ();
    final String SQL = "SELECT entitytype.name, entitytype.unique_key from role, entitytype, role_entity where role_entity._fk_rid = role._id and role.name = ${role} and entitytype.unique_key = role_entity._fk_etuk;";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("role", roleName);
    
      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        AllowableEntityType type = new AllowableEntityType ();
        DbResultRecord record = records.next ();
        type.setDescription (record.<String> get ("name"));
        type.setEntity (record.<String> get ("unique_key"));
        entityTypes.add (type);
      }
      return entityTypes;
  }

  public List<Permission> getPermissionsByComponent (SQLConnection connection, String component) throws ReturnStatusException {
    ArrayList<Permission> permissions = null;
    final String SQL = "select permission.name from permission, component, permission_role where component.name = ${compName} and component._id = permission_role._fk_cid and permission._id = permission_role._fk_pid group by permission.name;";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("compName", component);
    
      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      permissions = new ArrayList<Permission> ();
      while (records.hasNext ()) {
        Permission p = new Permission ();
        DbResultRecord record = records.next ();
        p.setName (record.<String> get ("name"));
        permissions.add (p);
      }
      return permissions;
  }

  private AllowableEntityType getAllowableEntityTypeByName (SQLConnection connection, String entity) throws ReturnStatusException {
    AllowableEntityType type = new AllowableEntityType ();
    final String SQL = "select name, unique_key from entitytype where entitytype.name = ${name}";

    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("name", entity);

      SingleDataResultSet results = executeStatement (connection, SQL,
          parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        DbResultRecord record = records.next ();
        type.setDescription (record.<String> get ("name"));
        type.setEntity (record.<String> get ("unique_key"));
        // For the role, build a list of Allowable Entity Types
      }
      return type;
  }

  public List<Permission> getAllPermissions (SQLConnection connection) throws ReturnStatusException {
    ArrayList<Permission> permissions = null;
    final String SQL = "SELECT distinct name FROM permission;";

      SingleDataResultSet results = executeStatement (connection, SQL,
          new SqlParametersMaps (), false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      permissions = new ArrayList<Permission> ();
      while (records.hasNext ()) {
        Permission p = new Permission ();
        DbResultRecord record = records.next ();
        p.setName (record.<String> get ("name"));
        permissions.add (p);
      }
      return permissions;
  }

  public Map<String, Object> getAllComponentsAndRoles (SQLConnection connection) throws ReturnStatusException {
	Map<String, Object> returnValue = new HashMap<String, Object> ();
    Collection<Role> roles = getAllRoles(connection);
    returnValue.put ("roles", roles);
    //Commented because not returning the permission and components with no role mapped to it.
//    final String SQL = "select role.name as name, permission.name as permissionname, component.name as componentname from role left outer join permission_role on permission_role._fk_rid=role._id left outer join permission on permission_role._fk_pid=permission._id left outer join component on permission_role._fk_cid=component._id order by componentname, permissionname;";

    //returning the permission and components with no role mapped to it.
    final String SQL = "select * from (select      role.name as name,     permission.name as permissionname,     component.name as componentname from     role         left outer join     permission_role ON permission_role._fk_rid = role._id         left outer join     permission ON permission_role._fk_pid = permission._id         left outer join     component ON permission_role._fk_cid = component._id union select null, permissionname, componentname from (select    permission.name as permissionname,     component.name as componentname,      max(permission_role._fk_rid) totalrecords from     permission , component , permission_role  where   permission._id = permission_role._fk_pid and    component._id = permission_role._fk_cid group by componentname , permissionname ) a where a.totalrecords is null) b order by componentname , permissionname; ";
    SingleDataResultSet results = executeStatement (connection, SQL, new SqlParametersMaps (), false).getResultSets ().next ();
    Iterator<DbResultRecord> records = results.getRecords ();	

    String prevpermissionname = null, prevcomponentname = null;
    List<HashMap<String, Object>> listOfMappings = new ArrayList<HashMap<String, Object>> ();
    HashMap<String, Object> permission_mappings = null;
    while (records.hasNext ()) {
    	DbResultRecord record = records.next ();
    	
    	//determines if this belongs to the same (component, permission) as a previous role
    	String componentname = record.<String> get ("componentname");
    	String permissionname = record.<String> get ("permissionname");
    	
    	//TODO handle null component/permission
    	if (componentname == null || permissionname == null)
    		continue;
    	
    	if (!componentname.equals(prevcomponentname) || !permissionname.equals(prevpermissionname)) {
    		if (permission_mappings != null) {
    			//add false mappings for roles not encountered for this component/permission
    			for (Role r: roles) {
    				if (!permission_mappings.containsKey(r.getRole()))
    					permission_mappings.put(r.getRole(), false);
    			}

    			//add previous to the outgoing result
    			listOfMappings.add(permission_mappings);
    		}
    		
    		//start over for new component/permission
    		permission_mappings = new HashMap<String, Object> ();
    		permission_mappings.put("Component", componentname);
    		permission_mappings.put("Permission", permissionname);
    	}
    	
    	String rolename = record.<String> get ("name");
    	if(rolename!=null) {
    	  permission_mappings.put(rolename, true);
    	}

    	prevpermissionname = permissionname;
    	prevcomponentname = componentname;
    }
    
    //special handling for last component/permission
    if (permission_mappings != null) {
		//add false mappings for roles not encountered for this component/permission
		for (Role r: roles) {
			if (!permission_mappings.containsKey(r.getRole()))
				permission_mappings.put(r.getRole(), false);
		}

		//add previous to the outgoing result
		listOfMappings.add(permission_mappings);
	}
    
    returnValue.put ("mappings", listOfMappings);
    return returnValue;
  }

  private Permission getPermission (SQLConnection connection, String permID) throws ReturnStatusException {

    Permission p = null;
    final String SQL_getPermission = "select name from permission where name = ${name}";
    SqlParametersMaps parameters = new SqlParametersMaps ();
    parameters.put ("name", permID);

      SingleDataResultSet results = executeStatement
          (connection, SQL_getPermission, parameters, false).getResultSets ().next ();
      Iterator<DbResultRecord> records = results.getRecords ();
      while (records.hasNext ()) {
        p = new Permission ();
        DbResultRecord record = records.next ();
        // build the permission from the db record.
        p.setName (record.<String> get ("name"));
      }
      return p;
  }
}